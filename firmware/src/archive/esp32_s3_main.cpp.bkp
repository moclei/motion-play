#include <Arduino.h>
#include <Wire.h>

// ============================================================================
// PIN CONFIGURATION for ESP32-S3-DevKitC-1
// ============================================================================
#define PIN_SDA 21 // I2C SDA for ESP32-S3-DevKitC-1 (using GPIO matrix)
#define PIN_SCL 20 // I2C SCL for ESP32-S3-DevKitC-1 (using GPIO matrix)

// ============================================================================
// VCNL4040 I2C ADDRESS AND REGISTERS
// ============================================================================
#define VCNL4040_ADDR 0x60

// VCNL4040 Register addresses
#define VCNL4040_ALS_CONF 0x00
#define VCNL4040_ALS_THDH 0x01
#define VCNL4040_ALS_THDL 0x02
#define VCNL4040_PS_CONF1 0x03
#define VCNL4040_PS_CONF3 0x04
#define VCNL4040_PS_MS 0x05
#define VCNL4040_PS_CANC 0x06
#define VCNL4040_PS_THDL 0x07
#define VCNL4040_PS_THDH 0x08
#define VCNL4040_PS_DATA 0x08
#define VCNL4040_ALS_DATA 0x09
#define VCNL4040_WHITE_DATA 0x0A
#define VCNL4040_INT_FLAG 0x0B
#define VCNL4040_ID 0x0C

// ============================================================================
// VCNL4040 CLASS - Simplified for direct I2C communication
// ============================================================================
class VCNL4040
{
public:
    bool begin();
    uint16_t readProximity();
    uint16_t readAmbientLight();
    uint16_t readWhiteLight();
    bool checkID();

private:
    void writeRegister(uint8_t reg, uint16_t data);
    uint16_t readRegister(uint8_t reg);
};

bool VCNL4040::begin()
{
    // Check if device is present and has correct ID
    if (!checkID())
    {
        return false;
    }

    // Configure ALS (Ambient Light Sensor)
    writeRegister(VCNL4040_ALS_CONF, 0x0000); // Enable ALS, 100ms integration

    // Configure PS (Proximity Sensor)
    writeRegister(VCNL4040_PS_CONF1, 0x0000); // Enable PS, default settings
    writeRegister(VCNL4040_PS_CONF3, 0x0000); // Default settings

    delay(100); // Let sensors stabilize
    return true;
}

bool VCNL4040::checkID()
{
    uint16_t id = readRegister(VCNL4040_ID);
    Serial.printf("VCNL4040 ID: 0x%04X (expected 0x0186)\n", id);
    return (id == 0x0186);
}

uint16_t VCNL4040::readProximity()
{
    return readRegister(VCNL4040_PS_DATA);
}

uint16_t VCNL4040::readAmbientLight()
{
    return readRegister(VCNL4040_ALS_DATA);
}

uint16_t VCNL4040::readWhiteLight()
{
    return readRegister(VCNL4040_WHITE_DATA);
}

void VCNL4040::writeRegister(uint8_t reg, uint16_t data)
{
    Wire.beginTransmission(VCNL4040_ADDR);
    Wire.write(reg);
    Wire.write(data & 0xFF);        // LSB first
    Wire.write((data >> 8) & 0xFF); // MSB second
    Wire.endTransmission();
}

uint16_t VCNL4040::readRegister(uint8_t reg)
{
    Wire.beginTransmission(VCNL4040_ADDR);
    Wire.write(reg);
    Wire.endTransmission(false);

    Wire.requestFrom((uint8_t)VCNL4040_ADDR, (uint8_t)2);
    if (Wire.available() >= 2)
    {
        uint8_t lsb = Wire.read();
        uint8_t msb = Wire.read();
        return (msb << 8) | lsb;
    }
    return 0;
}

// ============================================================================
// GLOBAL OBJECTS
// ============================================================================
VCNL4040 sensor;

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================
void scanI2C()
{
    Serial.println("=== I2C Device Scan ===");
    int deviceCount = 0;

    for (uint8_t addr = 1; addr < 127; addr++)
    {
        Serial.printf("Scanning address 0x%02X... ", addr);

        Wire.beginTransmission(addr);
        Wire.setTimeout(100); // 100ms timeout
        uint8_t error = Wire.endTransmission();

        if (error == 0)
        {
            Serial.printf("FOUND");
            if (addr == 0x60)
                Serial.print(" (VCNL4040)");
            Serial.println();
            deviceCount++;
        }
        else
        {
            Serial.println("No response");
        }

        // Add small delay and yield to prevent watchdog issues
        if (addr % 16 == 0)
        {
            delay(10);
            yield();
        }
    }

    Serial.println("======================");
    if (deviceCount == 0)
    {
        Serial.println("No I2C devices found!");
        Serial.println("Check connections and pull-up resistors");
    }
    else
    {
        Serial.printf("Found %d device(s)\n", deviceCount);
    }
}

void printSystemInfo()
{
    Serial.println("=== System Information ===");
    Serial.printf("Chip model: %s\n", ESP.getChipModel());
    Serial.printf("Chip revision: %d\n", ESP.getChipRevision());
    Serial.printf("CPU frequency: %d MHz\n", ESP.getCpuFreqMHz());
    Serial.printf("Flash size: %d bytes\n", ESP.getFlashChipSize());
    Serial.printf("Free heap: %d bytes\n", ESP.getFreeHeap());
    Serial.printf("Build time: %s %s\n", __DATE__, __TIME__);
    Serial.println("===========================");
}

// ============================================================================
// SETUP FUNCTION
// ============================================================================
void setup()
{
    // Initialize Serial with higher baud rate for better performance
    Serial.begin(115200);
    delay(2000); // Give time for serial monitor to connect

    Serial.println("\n\n=== ESP32-S3 VCNL4040 Test ===");
    printSystemInfo();

    // Initialize I2C with custom pins using setPins method
    Wire.setPins(PIN_SDA, PIN_SCL); // Set custom pins BEFORE begin()
    Wire.begin();                   // Initialize I2C
    Wire.setClock(100000);          // Start with slower 100kHz I2C speed
    Serial.printf("I2C initialized on SDA=%d, SCL=%d at 100kHz\n", PIN_SDA, PIN_SCL);

    // Test I2C bus health first
    Serial.println("Testing I2C bus health...");
    Wire.beginTransmission(0x00); // General call address
    uint8_t busTest = Wire.endTransmission();
    Serial.printf("I2C bus test result: %d (0=OK, others=error)\n", busTest);

    // Scan for I2C devices
    scanI2C();

    // Initialize VCNL4040 sensor
    Serial.println("Initializing VCNL4040...");
    if (!sensor.begin())
    {
        Serial.println("❌ Failed to initialize VCNL4040!");
        Serial.println("Check connections:");
        Serial.println("  VCC → 3.3V");
        Serial.println("  GND → GND");
        Serial.printf("  SDA → GPIO %d\n", PIN_SDA);
        Serial.printf("  SCL → GPIO %d\n", PIN_SCL);
        Serial.println("  Add 4.7kΩ pull-up resistors to SDA and SCL");
        while (1)
        {
            delay(1000);
            Serial.println("Retrying sensor initialization...");
            if (sensor.begin())
            {
                Serial.println("✅ Sensor initialized successfully!");
                break;
            }
        }
    }
    else
    {
        Serial.println("✅ VCNL4040 initialized successfully!");
    }

    Serial.println("=== Starting sensor readings ===");
    Serial.println("Format: [Time] Proximity: XXXX | Ambient: XXXX | White: XXXX");
}

// ============================================================================
// MAIN LOOP
// ============================================================================
void loop()
{
    static unsigned long lastReading = 0;
    const unsigned long readingInterval = 250; // Read every 250ms

    if (millis() - lastReading >= readingInterval)
    {
        // Read all sensor values
        uint16_t proximity = sensor.readProximity();
        uint16_t ambient = sensor.readAmbientLight();
        uint16_t white = sensor.readWhiteLight();

        // Print timestamp and readings
        Serial.printf("[%6lu ms] Proximity: %5d | Ambient: %5d | White: %5d",
                      millis(), proximity, ambient, white);

        // Add visual indicators for proximity
        if (proximity > 1000)
        {
            Serial.print(" 🔴 VERY CLOSE");
        }
        else if (proximity > 500)
        {
            Serial.print(" 🟡 CLOSE");
        }
        else if (proximity > 100)
        {
            Serial.print(" 🟢 NEAR");
        }
        else
        {
            Serial.print(" ⚫ FAR");
        }

        Serial.println();
        lastReading = millis();
    }

    // Handle any serial commands (optional debugging)
    if (Serial.available())
    {
        String command = Serial.readStringUntil('\n');
        command.trim();

        if (command == "scan")
        {
            scanI2C();
        }
        else if (command == "info")
        {
            printSystemInfo();
        }
        else if (command == "help")
        {
            Serial.println("Available commands:");
            Serial.println("  scan - Scan for I2C devices");
            Serial.println("  info - Show system information");
            Serial.println("  help - Show this help");
        }
    }
}
